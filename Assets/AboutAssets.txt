Any raw assets you want to be deployed with your application can be placed in
this directory (and child directories) and given a Build Action of "AndroidAsset".

These files will be deployed with your package and will be accessible using Android's
AssetManager, like this:

public class ReadAsset : Activity
{
	protected override void OnCreate (Bundle bundle)
	{
		base.OnCreate (bundle);

		InputStream input = Assets.Open ("my_asset.txt");
	}
}

Additionally, some Android functions will automatically load asset files:

Typeface tf = Typeface.CreateFromAsset (Context.Assets, "fonts/samplefont.ttf");


================================================================================================

Avoiding ImageBitmap OutOfMemoryException and Rounded corner Image in android xamarin

Why rounded corner Image bitmap not Working Properly

In Brief:
Circular shaped image display is the common requirment in most of the android application. Here i will write about how to create 
rounded corner/Circualr Image from the image bitmap and the possible issues with this process.

In  previous post i explained,How to use Google Place API with Autocomplete in Xamarin Android[http://appliedcodelog.blogspot.com/2015/05/google-place-api-with-autocomplete-in.html],
Integration of google map v2 in xamaron android[http://appliedcodelog.blogspot.com/2015/04/build-google-map-v2-in-xamarin-android.html],
Working on the wrong position and item click event issues with ListView in android xamarin[http://appliedcodelog.blogspot.com/2015/07/working-on-issues-with-listview-in.html]

[Image]

Description : 
Let us build one sample application to display image. Here image need to be fetch from SD card/Phone memory.

Whenever we need to load image bitmap to imageview it is must and should to analyse the image dimension and size.
Image captured from the device camer5a usually takes high resolution then the screen density and size .
RAM space allocated to the app may not enough to handle it properly which leads to OutOfMemoryException. 
Loading smaller subsampled version of image is the best approach to solve OutOfMemory issue. Which is to be achieved by reducing 
Image resolution, As per the xamarin document
[http://developer.xamarin.com/recipes/android/resources/general/load_large_bitmaps_efficiently/] Reducing the image resolution 
doesn't change any visual effect of the image.


Here i will take High resultion image XXXX *XXXX with size X.XXMB which is to be displayed with rouneded corner from SD card.

Step 1: Get BitmapOptions to find out the image current dimension.

string strImgPath =System.IO.Path.Combine( Android.OS.Environment.ExternalStorageDirectory.AbsolutePath,"Sample","sample.jpg") ;
BitmapFactory.Options option = await ImageHelper.GetBitmapOptionsOfImage ( strImgPath );
[Find called fuction below]
Step 2: For the target height,width of the UI component claculate InSampleSize ratio. InSampleSize value is used to scale down the
image and load smaller version of the image. InSampleSize value varies according to the image resolution and it is Factor of 2.

    var imgProfilePic = FindViewById<ImageView> ( Resource.Id.myImg );
    int width=imgProfilePic.MeasuredWidth/2;  [Note : MeasuredWidth and height will work only after image drawn fully]
	int height=imgProfilePic.MeasuredHeight/2; 
    var bitmapSampled = await LoadScaledDownBitmapForDisplayAsync ( strImgPath , option , width , height ); 

 Step 3: Get rounded corner image bitmap from the optimized bitmap obtained from the step2.  
        Here the important note is, to get rounded corner bitmap the input bitmap should have equal bitmap height and width.

        int intRoundPicResolution; 
		if(bitmapSampled.Height>bitmapSampled.Width)  //only to get circle shape
			intRoundPicResolution=bitmapSampled.Width;
		else
			intRoundPicResolution=bitmapSampled.Height;
		
		bitmapSampled = Bitmap.CreateScaledBitmap ( bitmapSampled , intRoundPicResolution , intRoundPicResolution , false );
		int pixel2 = ( bitmapSampled.Width ) / 2; 
		using ( var bitmapRoundedCorner = GetRoundedCornerBitmap ( bitmapSampled , pixel2 ) )
		{
			RecycleBitmap (imgProfilePic);
			imgProfilePic.SetImageBitmap ( bitmapRoundedCorner ); 
		} 
Step 4: Write back the sampled down Image bitmap to the phone storage[This requires WRITE_EXTERNAL_STORAGE]. 
Now we can see the optimized image resolution and size. In my phone storage it is showing XXXXX and XXXX
 


	internal async static Task<BitmapFactory.Options> GetBitmapOptionsOfImage(string strFileName)
		{
			BitmapFactory.Options options = new BitmapFactory.Options
			{
				InJustDecodeBounds = true //true-avoids memory allocation during decoding
			};
			 
			await BitmapFactory.DecodeFileAsync(strFileName, options); // The result will be null because InJustDecodeBounds == true.
			return options;
		}


	internal async static Task<Bitmap> LoadScaledDownBitmapForDisplayAsync(string strFileName, BitmapFactory.Options options, int reqWidth, int reqHeight)
		{
			// Calculate inSampleSize
			options.InSampleSize = CalculateInSampleSize(options, reqWidth, reqHeight);
			// Decode bitmap with inSampleSize set
			options.InJustDecodeBounds = false; //to let memory allocation during decoding 
			return await BitmapFactory.DecodeFileAsync(strFileName, options);
		}

internal static int CalculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight)
		{
			float height = options.OutHeight; // Raw height and width of image
			float width = options.OutWidth;
			double inSampleSize = 1D; 
			if (height > reqHeight || width > reqWidth)
			{
				int halfHeight = (int)(height / 2);
				int halfWidth = (int)(width / 2); 
				// Calculate a inSampleSize  - the decoder will use this value for sub sampling.
				while ((halfHeight / inSampleSize) > reqHeight && (halfWidth / inSampleSize) > reqWidth)
				{
					inSampleSize *= 2;
				} 
			} 
			return (int)inSampleSize; 
		} 
	
For this we convert image in to a Bitmap using  BitmapFactory class DecodeFile method. 


imgProfilePic.Width returns zero until it is drawn fully. 
		using(	Bitmap bitmap = BitmapFactory.DecodeFile ( localUrl ))
		{

	     imgProfilePic.SetImageBitmap ( GetRoundedCornerBitmap(bitmap) );

		}
		// If you would like to create a circle of the image set pixels to half the width of the image.
		internal static   Bitmap GetRoundedCornerBitmap(Bitmap bitmap, int pixels)
		{
			Bitmap output = null;

			try
			{
				output = Bitmap.CreateBitmap(bitmap.Width, bitmap.Height, Bitmap.Config.Argb8888);
				Canvas canvas = new Canvas(output);

				Color color = new Color(66, 66, 66);
				Paint paint = new Paint();
				Rect rect = new Rect(0, 0, bitmap.Width, bitmap.Height);
				RectF rectF = new RectF(rect);
				float roundPx = pixels;

				paint.AntiAlias = true;
				canvas.DrawARGB(0, 0, 0, 0);
				paint.Color = color;
				canvas.DrawRoundRect(rectF, roundPx, roundPx, paint);

				paint.SetXfermode(new PorterDuffXfermode(PorterDuff.Mode.SrcIn));
				canvas.DrawBitmap(bitmap, rect, rect, paint);
			}
			catch (System.Exception err)
			{
				System.Console.WriteLine ("GetRoundedCornerBitmap Error - " + err.Message);
			}

			return output;
		}